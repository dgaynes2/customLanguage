from Lexer import Lexer
import Tokens
import Errors

VARIABLES = {}

class Parser:
    def __init__(self,tokens):
        self.tokens = tokens
        self.index = -1
        self.current_token = None
        self.next()

        # track ( and ) characters
        self.parentheses_tracker = 0

    def next(self):
        self.index += 1
        self.current_token = self.tokens[self.index] if self.index < len(self.tokens) else None

    ##### SUGAR #####

    def apply_operation(self, result, op, operand):
        # Apply binary operations based on the given operator
        assert operand is not None, 'Operand cannot be None'
        if type(operand) in [int,float]:
            if op == 'ADD':
                return result + operand
            elif op == 'SUB':
                return result - operand
            elif op == 'MUL':
                return result * operand
            elif op == 'DIV': # /
                if operand != 0:
                    return result / operand
                return Errors.DivideByZeroError()
            elif op == 'FLD': # //
                if operand != 0:
                    return result // operand
                return Errors.DivideByZeroError()
            elif op == 'MOD': # %
                if operand != 0:
                    return result % operand
                return Errors.DivideByZeroError()
            else:
                return Errors.InvalidTextError('operator',op)
        else:
            return Errors.InvalidTextError('operand',operand)

    def apply_comparison(self,result,op,operand):
        # Apply comparison operations based on the given operator
        assert operand is not None, 'Operand cannot be None'
        if op == 'GT':
            return result > operand
        elif op == 'LT':
            return result < operand
        elif op == 'GEQ':
            return result >= operand
        elif op == 'LEQ':
            return result <= operand
        elif op == 'EQ':
            return result == operand
        elif op == 'NEQ':
            return result != operand

    def if_statement(self):
        if self.current_token.type == 'LS':
            self.next()
            condition_result = self.parse_expression()
            if self.current_token.type == 'RS':
                self.next()
            else:
                return Errors.MismatchedBracketsError(']')
        else:
            return Errors.MismatchedBracketsError('[')

        if self.current_token.type == 'LS':
            self.next()
            then_result = self.if_var_expr()
            if self.current_token.type == 'RS':
                self.next()
            else:
                return Errors.MismatchedBracketsError(']')
        else:
            return Errors.MismatchedBracketsError('[')

        if self.current_token.type == 'LS':
            self.next()
            else_result = self.if_var_expr()
            if self.current_token.type == 'RS':
                self.next()
            else:
                return Errors.MismatchedBracketsError(']')
        else:
            else_result = None

        return then_result if condition_result else else_result


    ##### INTERPRETING #####

    def parse(self):
        return self.check_parentheses_pairs()

    def check_parentheses_pairs(self):
        # track number of ( and ) characters. Different count -> error
        for token in self.tokens:
            if token.type == 'LP': # (
                self.parentheses_tracker += 1
            elif token.type == 'RP': # )
                self.parentheses_tracker -= 1
        # too many )
        if self.parentheses_tracker > 0:
            result = Errors.MismatchedParenthesesError(self.parentheses_tracker,')')
        # too many (
        elif self.parentheses_tracker < 0:
            result = Errors.MismatchedParenthesesError(self.parentheses_tracker,'(')
        else:
            # continue parsing if balanced parentheses
            result = self.if_var_expr()
        return result

    def if_var_expr(self):
        if self.current_token.type == 'KEY':
            if self.current_token.value == 'test':
                self.next()
                return self.if_statement()

            elif self.current_token.value == 'set':
                return self.parse_variables()

            else:
                return self.parse_expression()
        return self.parse_expression()

    def parse_variables(self):
        self.next()
        token = self.current_token
        if token.type == 'VAR':
            variable_name = token.value
            self.next()
            if self.current_token and self.current_token.value == 'is':
                self.next()
                VARIABLES[variable_name] = self.parse_expression()
                return Errors.SetVariableMessage(variable_name,VARIABLES[variable_name])
        return Errors.InvalidVariableAssignmentError()

    def parse_expression(self):
        result = self.parse_term()

        while self.current_token and self.current_token.type in {'ADD','SUB'}:
            if self.current_token.type == 'ADD':
                self.next()
                result += self.parse_term()
            elif self.current_token.type == 'SUB':
                self.next()
                if self.current_token and self.current_token.type in {'VAR','INT','FLT','LP'}:
                    term = self.parse_term()
                    if isinstance(term,(int,float)):
                        result -= term
                    else:
                        return term
                else:
                    return Errors.UnexpectedTokenError(self.current_token.value)

        while self.current_token and self.current_token.type in {'GT', 'LT', 'GEQ', 'LEQ', 'EQ', 'NEQ'}:
            op = self.current_token.type
            self.next()
            operand = self.parse_term()
            result = self.apply_comparison(result,op,operand)
        return result

    def parse_term(self):
        result = self.parse_exponent()

        while self.current_token and self.current_token.type in {'MUL', 'DIV', 'FLD', 'MOD'}:
            op = self.current_token.type
            self.next()
            operand = self.parse_exponent()
            result = self.apply_operation(result,op,operand)
        return result

    def parse_exponent(self):
        result = self.parse_factor()

        while self.current_token and self.current_token.type == 'POW':
            self.next()
            factor = self.parse_factor()
            if not isinstance(result, (int, float)) or not isinstance(factor, (int, float)):
                return Errors.ExponentError()
            result **= factor

        return result

    def parse_factor(self):
        token = self.current_token
        # get variable value
        if token.type == 'VAR':
            self.next()
            if token.value in VARIABLES:
                return VARIABLES[token.value]
            return Errors.InvalidVariableError(token.value)

        elif isinstance(token,(Tokens.FloatToken,Tokens.IntegerToken)):
            self.next()
            return float(token.value) if '.' in token.value else int(token.value)

        elif isinstance(token, Tokens.BracketToken) and token.type == 'LP':
            self.next()
            result = self.parse_expression()
            self.next()
            return result

        else:
            return Errors.UnexpectedTokenError(token.value)


def main():
    run = True
    while run:
        line = input('> ')
        if line.strip() == '':
            continue
        elif line.lower() in {'exit','quit'}:
            run = False
        elif line.strip().lower() == 'vardict':
            print(VARIABLES)
        elif line.lower().startswith('cleardict'):
            VARIABLES.clear()
            print('All variables deleted')
        elif line.lower().startswith('del'):
            lexer = Lexer(line[3:])
            tokens = lexer.make_tokens()
            if len(tokens) > 0:
                if tokens[0].type == 'VAR':
                    if tokens[0].value in VARIABLES:
                        VARIABLES.pop(tokens[0].value)
                        print(Errors.VariableDeletedMessage(tokens[0].value))
                    else:
                        print(f'Variable "{tokens[0].value}" not found')
                else:
                    print(Errors.VariableNotFoundError(tokens[0].value))
            else:
                print(Errors.DelSyntaxError())
        else:
            lexer = Lexer(line)
            tokens = lexer.make_tokens()
            parser = Parser(tokens)
            result = parser.check_parentheses_pairs()
            print(result)

if __name__ == '__main__':
    main()
