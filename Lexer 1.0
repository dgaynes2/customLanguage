import string
import Tokens

BLANKS = {' ','\t','\n'}
DIGITS = '1234567890'
LETTERS = string.ascii_letters
DIGLETTS = DIGITS + LETTERS
OPERATORS = {'+':'ADD','-':'SUB','/':'DIV','//':'FLD','///':'MOD','*':'MUL','**':'POW'}
BRACKETS = {'(':'LP',')':'RP','[':'LS',']':'RS'}
COMPARATIVES = {'>':'GT','<':'LT','>=':'GEQ','<=':'LEQ','=':'EQ','!=':'NEQ'}
KEYWORDS = {'is','set','del'}

########################################
# LEXER
########################################

class Lexer:
    def __init__(self,text):
        self.text = text
        self.index = -1
        self.current_char = None
        self.next()

    def next(self):
        # move to next char in output
        self.index += 1
        self.current_char = self.text[self.index] if self.index < len(self.text) else "EOF"

    def make_tokens(self):
        tokens = []

        while self.current_char:
            # ignore blank space
            if self.current_char in BLANKS:
                self.next()
            # differentiate between subtraction token and negative number token
            # elif self.current_char == '-':
            #     if self.text[self.index + 1] and self.text[self.index + 1] in DIGITS + '.':
            #         tokens.append(self.make_number())
            #         self.next()
            #     else:
            #         tokens.append(Tokens.OperatorToken('SUB','-'))
            #         self.next()
            # # numbers 1 2 3 4 5 6 7 8 9 0 . -
            # elif self.current_char in DIGITS + '.' + '-':
            #     tokens.append(self.make_number())
            elif self.current_char in DIGITS + '.':
                tokens.append(self.make_number())
            # words
            elif self.current_char in LETTERS:
                tokens.append(Tokens.Token(*self.make_word()))
            # operators + - / // /// * **
            elif self.current_char in OPERATORS:
                tokens.append(Tokens.OperatorToken(*self.make_operator()))
            # brackets ( ) [ ]
            elif self.current_char in BRACKETS:
                tokens.append(Tokens.BracketToken(BRACKETS[self.current_char],self.current_char))
                self.next()
            # comparatives > >= < <= = !=
            elif self.current_char in '><!=':
                tokens.append(Tokens.ComparativeToken(*self.make_comparative()))
            # EOF
            elif self.current_char == 'EOF':
                break
            # unknown character
            else:
                return f'Error: unknown character, {self.current_char}'
        return tokens

    def make_number(self):
        num_str = self.current_char
        decimal_count = 1 if self.current_char == '.' else 0
        self.next()

        while self.current_char and self.current_char in DIGITS + '.':
            if self.current_char == '.':
                if decimal_count == 1:
                    return 'Error: too many decimals'
                decimal_count += 1
            num_str += self.current_char
            self.next()

        # 0 before beginning decimal
        if num_str.startswith('.'):
            num_str = '0' + num_str
        # -.1 -> -0.1
        elif num_str.startswith('-') and num_str[1] == '.':
            _ = '-0'
            for i in num_str[1]:
                _ += i
            num_str = _

        # 0 after ending decimal
        if num_str.endswith('.'):
            num_str += '0'

        # remove leading 0s
        if decimal_count == 0:
            if num_str.startswith('0'):
                while num_str.startswith('0'):
                    num_str = num_str[1:]
            # -000001 -> -1
            elif num_str.startswith('-'):
                num_str = num_str[1:]
                if num_str.startswith('0'):
                    while num_str.startswith('0'):
                        num_str = num_str[1:]
                num_str = '-' + num_str

        return Tokens.FloatToken(num_str) if decimal_count else Tokens.IntegerToken(num_str)
        # return 'FLT' if decimal_count == 1 else 'INT',num_str

    def make_word(self):
        word_str = self.current_char
        self.next()

        while self.current_char in LETTERS + '_':
            word_str += self.current_char
            self.next()

        return 'KEY' if word_str in KEYWORDS else 'VAR',word_str

    def make_operator(self):
        op_str = self.current_char

        if self.text[self.index+1]:
            if self.text[self.index+1] == op_str[-1]:
                self.next()
                op_str += self.current_char
                if self.text[self.index + 1]:
                    if self.text[self.index + 1] == op_str[-1]:
                        self.next()
                        op_str += self.current_char
        self.next() 
        return OPERATORS[op_str],op_str

    def make_comparative(self):
        com_str = self.current_char
        self.next()

        if self.current_char == '=':
            com_str += self.current_char

        if com_str == '!':
            return 'Error: "!" needs a following "="'

        self.next()
        return COMPARATIVES[com_str],com_str



def token_test():
    to_test = {
        'OP': '+ - * ** / // ///',
        'INT': '1 -1 01 -01 10 -10',
        'FLT':'. -. .1 1. 1.1 -1.',
        'CMPR':'> >= < <= != =',
        'BRKT':'( ) [ ]',
        'CMBO':'2.5**4///(7.66)+1-1',
        'KEY':'is set del'
    }
    for _set_ in to_test:
        to_show = f"| {_set_}{' '*(5-len(_set_))}: "
        lexer = Lexer(to_test[_set_])

        for i in lexer.make_tokens():
            to_show += f"{i.type}:{i.value}, "
        to_show = to_show.strip(', ') # remove final comma
        print(to_show)

# token_test()
