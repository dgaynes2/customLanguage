import Categories
import Tokens

class Lexer:
    def __init__(self,text):
        self.text = text
        self.index = -1
        self.current_char = None
        self.next()

    def next(self):
        self.index += 1
        self.current_char = self.text[self.index] if self.index < len(self.text) else "EOF"

    def peek(self,how_far=1,look_for=None):
        # check existence and content of index-n
        if not look_for:
            return self.text[self.index + how_far]
        else:
            return self.text[self.index + how_far] and self.text[self.index + how_far] == look_for

    def get_next_char(self):
        # find next non-blank and peek it
        n = 0
        while self.text[self.index + n] in Categories.BLANKS:
            n += 1
        return n

    def skip_spaces(self):
        # continue increasing index while no char found
        while self.current_char in Categories.BLANKS:
            self.next()

    def make_tokens(self):
        tokens = []

        while self.current_char:
            # ignore blanks
            if self.current_char in Categories.BLANKS:
                self.next()
            # numbers 0 1 2 3 4 5 6 7 8 9 .
            elif self.current_char in Categories.DIGITS + '.':
                tokens.append(self.make_number())
            # operators
            elif self.current_char in Categories.OPERATORS:
                tokens.append(Tokens.OperatorToken(*self.make_operator()))
            # brackets ( ) [ ]
            elif self.current_char in Categories.BRACKETS:
                tokens.append(Tokens.BracketToken(Categories.BRACKETS[self.current_char],self.current_char))
                self.next()
            # comparatives > >= < <= = !=
            elif self.current_char in '><!=':
                tokens.append(Tokens.ComparativeToken(*self.make_comparative()))
            # words
            elif self.current_char in Categories.LETTERS:
                tokens.append(Tokens.Token(*self.make_word()))

            # EOF
            elif self.current_char == 'EOF':
                break

            # unknown character
            else:
                return f'Error: unknown character, {self.current_char}'

        # I hate this. How to incorporate
        for token in tokens:
            if isinstance(token,Tokens.OperatorToken):
                if tokens[tokens.index(token)+1]:
                    n = tokens[tokens.index(token)+1]
                    if isinstance(n,Tokens.OperatorToken) and n.type == 'SUB':
                        if tokens[tokens.index(token)+2]:
                            m = tokens[tokens.index(token)+2]
                            if isinstance(m,Tokens.IntegerToken) or isinstance(m,Tokens.FloatToken):
                                m.value = '-' + m.value
                                tokens.remove(n)


        return tokens

    def make_number(self,negative=False):
        num_str = self.current_char
        decimal_count = 1 if self.current_char == '.' else 0
        self.next()

        while self.current_char and self.current_char in Categories.DIGITS + '.':
            if self.current_char == '.':
                if decimal_count == 1:
                    return 'Error: too many decimals'
                decimal_count += 1
            num_str += self.current_char
            self.next()

        # 0 before leading decimal
        if num_str.startswith('.'):
            num_str = '0' + num_str

        # 0 after ending decimal
        if num_str.endswith('.'):
            num_str += '0'

        # remove extra leading 0's
        if decimal_count == 0:
            if num_str.startswith('0'):
                while num_str.startswith('0'):
                    num_str = num_str[1:]

        if negative:
            num_str = '-' + num_str
        return Tokens.FloatToken(num_str) if decimal_count else Tokens.IntegerToken(num_str)

    def make_word(self):
        word_str = self.current_char
        self.next()

        while self.current_char and self.current_char in Categories.LETTERS + '_':
            word_str += self.current_char
            self.next()

        return 'KEY' if word_str in Categories.KEYWORDS else 'MATH' if word_str in Categories.MATH else 'VAR', word_str

    def make_operator(self):
        # + - / *
        op_str = self.current_char

        if self.peek():
            if self.peek(self.get_next_char()) == '-':
                self.next()
                return 'SUB','-'

            # // **
            elif self.peek() and self.peek() == op_str[-1]:
                self.next()
                op_str += self.current_char
                # ///
                if self.peek():
                    if self.peek() and self.peek() == op_str[-1]:
                        self.next()
                        op_str += self.current_char
            self.next()
        return Categories.OPERATORS[op_str], op_str

    def make_comparative(self):
        comp_str = self.current_char
        self.next()

        if self.current_char == '=':
            comp_str += self.current_char
            self.next()

        if comp_str == '!':
            return 'Error: "!" needs a following "="'

        return Categories.COMPARATIVES[comp_str], comp_str
