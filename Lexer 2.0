import Categories
import Tokens

class Lexer:
    def __init__(self,text):
        self.text = text
        self.index = -1
        self.current_char = None
        self.next()

    def next(self):
        self.index += 1
        self.current_char = self.text[self.index] if self.index < len(self.text) else "EOF"

    def make_tokens(self):
        tokens = []

        while self.current_char:
            # ignore blanks
            if self.current_char in Categories.BLANKS:
                self.next()
            # numbers 1 2 3 4 5 6 7 8 9 0 . -
            elif self.current_char in Categories.DIGITS + '.' + '-':
                if self.current_char == '-':
                    # part of negative number
                    if self.text[self.index + 1] and self.text[self.index + 1] in Categories.DIGITS + '.':
                        tokens.append(self.make_number())
                    # subtraction
                    else:
                        tokens.append(Tokens.OperatorToken('SUB','-'))
                        self.next()
                else:
                    tokens.append(self.make_number())
            # operators
            elif self.current_char in Categories.OPERATORS:
                tokens.append(Tokens.OperatorToken(*self.make_operator()))
            # brackets ( ) [ ]
            elif self.current_char in Categories.BRACKETS:
                tokens.append(Tokens.BracketToken(Categories.BRACKETS[self.current_char],self.current_char))
                self.next()
            # comparatives > >= < <= = !=
            elif self.current_char in '><!=':
                tokens.append(Tokens.ComparativeToken(*self.make_comparative()))
            # words
            elif self.current_char in Categories.LETTERS:
                tokens.append(Tokens.Token(*self.make_word()))
            # EOF
            elif self.current_char == 'EOF':
                break
            # unknown character
            else:
                return f'Error: unknown character, {self.current_char}'
        return tokens

    def make_number(self):
        num_str = self.current_char
        decimal_count = 1 if self.current_char == '.' else 0
        self.next()

        while self.current_char and self.current_char in Categories.DIGITS + '.':
            if self.current_char == '.':
                if decimal_count == 1:
                    return 'Error: too many decimals'
                decimal_count += 1
            num_str += self.current_char
            self.next()

        # 0 before leading decimal
        if num_str.startswith('.'):
            num_str = '0' + num_str
        # -.1 -> -0.1
        elif num_str.startswith('-') and num_str[1] == '.':
            _ = '-0'
            for i in num_str[1]:
                _ += i
            num_str = _

        # 0 after ending decimal
        if num_str.endswith('.'):
            num_str += '0'

        # remove extra leading 0's
        if decimal_count == 0:
            if num_str.startswith('0'):
                while num_str.startswith('0'):
                    num_str = num_str[1:]
            # -00001 -> -1
            elif num_str.startswith('-'):
                num_str = num_str[1:]
                if num_str.startswith('0'):
                    while num_str.startswith('0'):
                        num_str = num_str[1:]
                num_str = '-' + num_str

        return Tokens.FloatToken(num_str) if decimal_count else Tokens.IntegerToken(num_str)

    def make_word(self):
        word_str = self.current_char
        self.next()

        while self.current_char and self.current_char in Categories.LETTERS + '_':
            word_str += self.current_char
            self.next()

        return 'KEY' if word_str in Categories.KEYWORDS else 'VAR', word_str

    def make_operator(self):
        # + - / *
        op_str = self.current_char

        if self.text[self.index + 1]:
            # // **
            if self.text[self.index + 1] and self.text[self.index + 1] == op_str[-1]:
                self.next()
                op_str += self.current_char
                # ///
                if self.text[self.index + 1]:
                    if self.text[self.index + 1] and self.text[self.index + 1] == op_str[-1]:
                        self.next()
                        op_str += self.current_char
        self.next()
        return Categories.OPERATORS[op_str], op_str

    def make_comparative(self):
        comp_str = self.current_char
        self.next()

        if self.current_char == '=':
            comp_str += self.current_char
            self.next()

        if comp_str == '!':
            return 'Error: "!" needs a following "="'

        return Categories.COMPARATIVES[comp_str], comp_str

def token_test():
    to_test = {
        'OP': '+ - * ** / // ///',
        'INT': '1 -1 01 -01 10 -10',
        'FLT':'. -. .1 1. 1.1 -1.',
        'CMPR':'> >= < <= != =',
        'BRKT':'( ) [ ]',
        'CMBO':'2.5**4///(7.66)+1--1',
        'KEY':'is set del test',
        'a':'test[(2 * 3)-1 >= 1.44 ** 3][2 + 2][3 + 3]',
        'b':'test[(2 * 3)- 1 >= 1.44 ** 3][2 + 2][3 + 3]',
        'c':'test[(2 * 3)- -1 >= 1.44 ** 3][2 + 2][3 + 3]',
    }
    for _set_ in to_test:
        to_show = f"| {_set_}{' '*(5-len(_set_))}: "
        lexer = Lexer(to_test[_set_])

        for i in lexer.make_tokens():
            to_show += f"{i.type}:{i.value}, "
        to_show = to_show.strip(', ') # remove final comma
        print(to_show)
token_test()
