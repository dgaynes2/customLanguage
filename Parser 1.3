from Lexer import Lexer
import Tokens
import Errors

VARIABLES = {}

class Parser:
    def __init__(self,tokens):

        self.tokens = tokens
        self.index = -1
        self.current_token = None
        self.next()

        # track ( and ) characters
        self.parentheses_tracker = 0

    def next(self):
        self.index += 1
        self.current_token = self.tokens[self.index] if self.index < len(self.tokens) else None

    def parse(self):
        return self.pre_parse_matching_parentheses_check()

    def pre_parse_matching_parentheses_check(self):
        # track number of ( and )
        for token in self.tokens:
            if token.type == 'LP':
                self.parentheses_tracker += 1
            elif token.type == 'RP':
                self.parentheses_tracker -= 1
        # return error if not same number
        if self.parentheses_tracker > 0:
            result = Errors.MismatchedParenthesesError(self.parentheses_tracker,')')
        elif self.parentheses_tracker < 0:
            result = Errors.MismatchedParenthesesError(abs(self.parentheses_tracker),'(')
        else:
            result = self.parse_set_var_or_expr()

        return result

    ##### sugar #####

    def apply_operation(self, result, op, operand):
        # Apply binary operations based on the given operator
        assert operand is not None, 'Operand cannot be None'
        if type(operand) in [int,float]:
            if op == 'ADD':
                return result + operand
            elif op == 'SUB':
                return result - operand
            elif op == 'MUL':
                return result * operand
            elif op == 'DIV': # /
                if operand != 0:
                    return result / operand
                return Errors.DivideByZeroError()
            elif op == 'FLD': # //
                if operand != 0:
                    return result // operand
                return Errors.DivideByZeroError()
            elif op == 'MOD': # %
                if operand != 0:
                    return result % operand
                return Errors.DivideByZeroError()
            else:
                return Errors.InvalidTextError('operator',op)
        else:
            return Errors.InvalidTextError('operand',operand)

    def apply_comparison(self,result,op,operand):
        # Apply comparison operations based on the given operator
        assert operand is not None, 'Operand cannot be None'
        if op == 'GT':
            return result > operand
        elif op == 'LT':
            return result < operand
        elif op == 'GEQ':
            return result >= operand
        elif op == 'LEQ':
            return result <= operand
        elif op == 'EQ':
            return result == operand
        elif op == 'NEQ':
            return result != operand

    ##### interpreting begins here #####

    def parse_set_var_or_expr(self):
        if self.current_token.type == 'KEY' and self.current_token.value == 'test':
            self.next()  # Move to the next token after 'test'

            # Parse if-statement inside the first pair of square brackets
            if self.current_token.type == 'LS':
                self.next()  # Move to the next token after '['
                condition_result = self.parse_expression()
                if self.current_token.type == 'RS':
                    self.next()  # Move to the next token after ']'
                else:
                    return Errors.MismatchedBracketsError(']')
            else:
                return Errors.MismatchedBracketsError('[')

            # Execute then-statement inside the second pair of square brackets if the if-statement is true
            if self.current_token.type == 'LS':
                self.next()  # Move to the next token after '['
                then_result = self.parse_set_var_or_expr()
                if self.current_token.type == 'RS':
                    self.next()  # Move to the next token after ']'
                else:
                    return Errors.MismatchedBracketsError(']')
            else:
                return Errors.MismatchedBracketsError(']')

            # Execute else-statement inside the third pair of square brackets if provided
            if self.current_token.type == 'LS':
                self.next()  # Move to the next token after '['
                else_result = self.parse_set_var_or_expr()
                if self.current_token.type == 'RS':
                    self.next()  # Move to the next token after ']'
                else:
                    return Errors.MismatchedBracketsError(']')
            else:
                else_result = None

            return then_result if condition_result else else_result

        elif self.current_token.type == 'KEY':
            if self.current_token.value == 'set':
                return self.parse_variables()
        else:
            return self.parse_expression()

    def parse_variables(self):
        self.next()
        token = self.current_token # var
        if token.type == 'VAR':
            variable_name = token.value
            self.next()
            if self.current_token and self.current_token.value == 'is':
                self.next()
                VARIABLES[variable_name] = self.parse_expression()
                return Errors.SetVariableMessage(variable_name,VARIABLES[variable_name])
        return Errors.InvalidVariableAssignmentError()

    def parse_expression(self):
        result = self.parse_term()

        while self.current_token and self.current_token.type in {'ADD','SUB'}:
            if self.current_token.type == 'ADD':
                self.next()
                result += self.parse_term()
            elif self.current_token.type == 'SUB':
                self.next()
                result -= self.parse_term()

        # is current token comparison > >= < <= != ==
        while self.current_token and self.current_token.type in {'GT', 'LT', 'GEQ', 'LEQ', 'EQ', 'NEQ'}:
            op = self.current_token.type
            self.next()
            operand = self.parse_term()
            # Handle the comparison based on the operator
            result = self.apply_comparison(result,op,operand)
        return result

    def parse_term(self):
        result = self.parse_exponent()

        while self.current_token and self.current_token.type in {'MUL', 'DIV', 'FLD', 'MOD'}:
            op = self.current_token.type
            self.next()
            operand = self.parse_exponent()
            result = self.apply_operation(result,op,operand)
        return result

    def parse_exponent(self):
        result = self.parse_factor()

        while self.current_token and self.current_token.type == 'POW':
            self.next()
            factor = self.parse_factor()
            if not isinstance(result, (int, float)) or not isinstance(factor, (int, float)):
                return Errors.ExponentError()
            result **= factor

        return result

    def parse_factor(self):
        token = self.current_token
        # get variable value
        if token.type == 'VAR':
            self.next()
            if token.value in VARIABLES:
                return VARIABLES[token.value]
            return Errors.InvalidVariableError(token.value)

        elif isinstance(token,(Tokens.FloatToken,Tokens.IntegerToken)):
            self.next()
            return float(token.value) if '.' in token.value else int(token.value)

        elif isinstance(token, Tokens.BracketToken) and token.type == 'LP':
            self.next()
            result = self.parse_expression()
            self.next()
            return result

        # keywords
        # constants
        # monos
        # negative number?
        else:
            return Errors.UnexpectedTokenError(token.value)

def main():
    run = True
    while run:
        line = input('> ')
        if line.strip() == '':
            continue
        elif line.lower() in {'exit','quit'}:
            run = False
        elif line.strip().lower() == 'vardict':
            print(VARIABLES)
        elif line.lower().startswith('cleardict'):
            VARIABLES.clear()
            print('All variables deleted')
        elif line.lower().startswith('del'):
            lexer = Lexer(line[3:])
            tokens = lexer.make_tokens()
            if len(tokens) > 0:
                if tokens[0].type == 'VAR':
                    if tokens[0].value in VARIABLES:
                        VARIABLES.pop(tokens[0].value)
                        print(Errors.VariableDeletedMessage(tokens[0].value))
                    else:
                        print(f'Variable "{tokens[0].value}" not found')
                else:
                    print(Errors.VariableNotFoundError(tokens[0].value))
            else:
                print(Errors.DelSyntaxError())
        else:
            lexer = Lexer(line)
            tokens = lexer.make_tokens()
            parser = Parser(tokens)
            result = parser.pre_parse_matching_parentheses_check()
            print(result)

if __name__ == '__main__':
    main()
